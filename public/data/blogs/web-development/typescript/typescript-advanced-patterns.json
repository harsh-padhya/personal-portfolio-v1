{
  "id": "typescript-advanced-patterns",
  "title": "Advanced TypeScript Patterns for Better Code",
  "category": "web-development",
  "subcategory": "typescript",
  "tags": ["typescript", "patterns", "generics", "advanced"],
  "publishDate": "2025-08-18T14:30:00.000Z",
  "lastModified": "2025-08-18T14:30:00.000Z",
  "readTime": "10 min read",
  "excerpt": "Explore advanced TypeScript patterns including conditional types, mapped types, and utility types to write more robust and maintainable code.",
  "content": "# Advanced TypeScript Patterns for Better Code\n\nTypeScript's type system is incredibly powerful, offering features that go far beyond basic type annotations. In this article, we'll explore advanced patterns that can help you write more robust, maintainable, and expressive code.\n\n## 1. Conditional Types\n\nConditional types allow you to create types that depend on a condition, similar to ternary operators in JavaScript.\n\n```typescript\ntype IsArray<T> = T extends any[] ? true : false;\n\ntype Test1 = IsArray<string[]>; // true\ntype Test2 = IsArray<string>;   // false\n\n// More practical example\ntype ApiResponse<T> = T extends string \n  ? { message: T } \n  : { data: T };\n\ntype StringResponse = ApiResponse<string>; // { message: string }\ntype UserResponse = ApiResponse<User>;     // { data: User }\n```\n\n## 2. Mapped Types\n\nMapped types let you create new types by transforming properties of existing types.\n\n```typescript\n// Make all properties optional\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\n// Make all properties readonly\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\n// Create a type with specific property transformations\ntype Getters<T> = {\n  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P];\n};\n\ninterface User {\n  name: string;\n  age: number;\n}\n\ntype UserGetters = Getters<User>;\n// { getName: () => string; getAge: () => number; }\n```\n\n## 3. Template Literal Types\n\nTemplate literal types enable creating types from string templates.\n\n```typescript\ntype EventName<T extends string> = `on${Capitalize<T>}`;\ntype Event = EventName<'click' | 'hover'>; // 'onClick' | 'onHover'\n\n// Dynamic object keys\ntype ApiEndpoint<T extends string> = `/api/${T}`;\ntype UserEndpoints = ApiEndpoint<'users' | 'profiles'>; \n// '/api/users' | '/api/profiles'\n\n// Complex template patterns\ntype CSSProperty<T extends string> = `--${T}`;\ntype CSSVariables = CSSProperty<'primary-color' | 'font-size'>;\n// '--primary-color' | '--font-size'\n```\n\n## 4. Utility Types in Action\n\n### Pick and Omit\n\n```typescript\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n  password: string;\n  createdAt: Date;\n}\n\n// Create a public user type without sensitive data\ntype PublicUser = Omit<User, 'password'>;\n\n// Create a user creation type\ntype CreateUser = Pick<User, 'name' | 'email' | 'password'>;\n\n// Or using Omit\ntype CreateUser2 = Omit<User, 'id' | 'createdAt'>;\n```\n\n### Record Type\n\n```typescript\n// Create a type for a dictionary/map\ntype UserRoles = Record<string, 'admin' | 'user' | 'guest'>;\n\nconst userRoles: UserRoles = {\n  'user1': 'admin',\n  'user2': 'user',\n  'user3': 'guest'\n};\n\n// More specific keys\ntype ThemeColors = Record<'primary' | 'secondary' | 'accent', string>;\n\nconst theme: ThemeColors = {\n  primary: '#007bff',\n  secondary: '#6c757d',\n  accent: '#28a745'\n};\n```\n\n## 5. Generic Constraints\n\nUse constraints to limit generic parameters to specific types.\n\n```typescript\n// Constraint to object types\nfunction getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {\n  return obj[key];\n}\n\nconst user = { name: 'John', age: 30 };\nconst name = getProperty(user, 'name'); // string\nconst age = getProperty(user, 'age');   // number\n\n// Constraint with conditions\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length);\n  return arg;\n}\n\nloggingIdentity('hello');      // ✓ string has length\nloggingIdentity([1, 2, 3]);    // ✓ array has length\nloggingIdentity({ length: 10, value: 3 }); // ✓ object has length\n```\n\n## 6. Discriminated Unions\n\nCreate type-safe unions using discriminator properties.\n\n```typescript\ninterface LoadingState {\n  status: 'loading';\n}\n\ninterface SuccessState {\n  status: 'success';\n  data: any;\n}\n\ninterface ErrorState {\n  status: 'error';\n  error: string;\n}\n\ntype AsyncState = LoadingState | SuccessState | ErrorState;\n\nfunction handleState(state: AsyncState) {\n  switch (state.status) {\n    case 'loading':\n      return 'Loading...';\n    case 'success':\n      return state.data; // TypeScript knows data exists\n    case 'error':\n      return state.error; // TypeScript knows error exists\n  }\n}\n```\n\n## 7. Recursive Types\n\nCreate types that reference themselves for nested structures.\n\n```typescript\ntype JsonValue = \n  | string\n  | number\n  | boolean\n  | null\n  | JsonValue[]\n  | { [key: string]: JsonValue };\n\n// File system structure\ninterface FileNode {\n  name: string;\n  type: 'file' | 'directory';\n  children?: FileNode[];\n}\n\n// Recursive tree structure\ntype TreeNode<T> = {\n  value: T;\n  children: TreeNode<T>[];\n};\n```\n\n## 8. Advanced Function Types\n\n### Function Overloads\n\n```typescript\nfunction parseValue(value: string): string;\nfunction parseValue(value: number): number;\nfunction parseValue(value: boolean): boolean;\nfunction parseValue(value: unknown): unknown {\n  return value;\n}\n\nconst str = parseValue('hello');  // string\nconst num = parseValue(42);       // number\nconst bool = parseValue(true);    // boolean\n```\n\n### Higher-Order Function Types\n\n```typescript\ntype EventHandler<T> = (event: T) => void;\ntype AsyncHandler<T, R> = (data: T) => Promise<R>;\n\n// Function that returns a function\ntype CurriedFunction<T, U, R> = (a: T) => (b: U) => R;\n\nconst add: CurriedFunction<number, number, number> = \n  (a) => (b) => a + b;\n\nconst addFive = add(5);\nconst result = addFive(3); // 8\n```\n\n## 9. Brand Types\n\nCreate branded types for enhanced type safety.\n\n```typescript\ntype Brand<T, B> = T & { __brand: B };\n\ntype UserId = Brand<string, 'UserId'>;\ntype ProductId = Brand<string, 'ProductId'>;\n\nfunction createUserId(id: string): UserId {\n  return id as UserId;\n}\n\nfunction getUser(id: UserId): User {\n  // Implementation\n}\n\nconst userId = createUserId('user123');\nconst productId = 'product456' as ProductId;\n\ngetUser(userId);    // ✓ Valid\ngetUser(productId); // ✗ Type error\n```\n\n## 10. Practical Example: Type-Safe API Client\n\n```typescript\ntype HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE';\n\ntype ApiEndpoints = {\n  'GET /users': { response: User[] };\n  'GET /users/:id': { params: { id: string }; response: User };\n  'POST /users': { body: CreateUser; response: User };\n  'PUT /users/:id': { params: { id: string }; body: Partial<User>; response: User };\n  'DELETE /users/:id': { params: { id: string }; response: void };\n};\n\ntype ExtractEndpoint<T extends string> = T extends `${HttpMethod} ${infer U}` ? U : never;\ntype ExtractMethod<T extends string> = T extends `${infer M} ${string}` ? M : never;\n\nclass ApiClient {\n  async request<K extends keyof ApiEndpoints>(\n    endpoint: K,\n    options?: ApiEndpoints[K] extends { params: infer P } ? { params: P } : never,\n    body?: ApiEndpoints[K] extends { body: infer B } ? B : never\n  ): Promise<ApiEndpoints[K]['response']> {\n    // Implementation\n    return {} as ApiEndpoints[K]['response'];\n  }\n}\n\nconst api = new ApiClient();\n\n// Type-safe API calls\nconst users = await api.request('GET /users');\nconst user = await api.request('GET /users/:id', { params: { id: '123' } });\nconst newUser = await api.request('POST /users', undefined, { name: 'John', email: 'john@example.com' });\n```\n\n## Conclusion\n\nThese advanced TypeScript patterns enable you to:\n\n- Create more expressive and type-safe APIs\n- Catch errors at compile time\n- Improve code maintainability and refactoring safety\n- Build robust applications with better developer experience\n\nMaster these patterns gradually, and you'll find yourself writing more confident and reliable TypeScript code. Remember, the goal is not to use every advanced feature, but to choose the right tool for each specific problem.",
  "featured": false,
  "difficulty": "advanced",
  "status": "published",
  "author": "Alex Johnson"
}
